;gets a binary operand from stin (piped from another program), calculates the hex value using that and a hex operand and char operator(order of this matters - assume binary operand on opposite side of operater) then translates back to hex and prints to stout
%include	'./mystdasmlib/genreg.ah'
%include	'./mystdasmlib/hex.ah'
%include	'./mystdasmlib/syscall.ah'
%include	'./mystdasmlib/cstring.ah'
%include	'./mystdasmlib/size.ah'
%include	'./mystdasmlib/util.ah'
%include	'./hcalc.ah'

global	main
section	.bss
	argv:	resq	1
	buff:	resb	9
	inbuff:	resq	1
section	.data
	newstrla	help,	'Put your expression into the arguments, each symbol and number separated by spaces.'
	newstrla	max,	'Program is limited to 8 bytes (16 hex chars) in each number and only one operation.'
	newstrla	badop,	'Must use + or - between hex numbers.'

section	.code

testisop:
	mov	al,	'+'
	cmp	dl,	al
	je	.true
	mov	al,	'-'
	cmp	dl,	al
	je	.true
	mov	al,	'x'
	cmp	dl,	al
	je	.true
	mov	al,	'/'
	cmp	dl,	al
	je	.true
	mov	rax,	0
	ret
.true:	mov	rax,	1
	ret

handlebadop:
	badop
main:
	mov	rax,	1
	cmp	rax,	rdi
	jne	prsargs
	noargs
prsargs:;parse args
	mov	[argv],	rsi
	add	rsi,	qsize(1);select argv[1]
	mov	rsi,	[rsi]
	xor	rdi,	rdi
	xor	rdx,	rdx

	rdztstrc	rdx,	rax,	rdi,	rsi,	r11
	mov	r12,	1
	cmp	r11,	r12
	jne	.cont1;continue 1
	jmp	testisop
	mov	dil,	1
	cmp	al,	dil
	jne	.cont1
	push	word 0
	read	stdin,	inbuff,	8
	mov	r9,	[inbuff]
	jmp	.skip1
.cont1:	frhexdu	r9,	rsi,	rdx
.skip1:	mov	rsi,	[argv]
	add	rsi,	qsize(3);select argv[2]
	mov	rsi,	[rsi]
	xor	rdx,	rdx

	rdztstrc	rdx,	rax,	rdi,	rsi,	r11
	mov	r12,	1
	cmp	r11,	r12
	jne	.cont2
	jmp	testisop
	mov	dil,	1
	cmp	al,	dil
	jne	.cont2
	push	word 1
	read	stdin,	inbuff,	8
	mov	r9,	[inbuff]
	jmp	.skip2
.cont2:	frhexdu r10,	rsi,	rdx
.skip2:	pop	dx
	mov	dil,	'+'
	cmp	dil,	dl
	je	add
	mov	dil,	'-'
	cmp	dil,	dl
	je	sub
	mov	dil,	'x'
	cmp	dil,	dl
	je	mul
	mov	dil,	'/'
	cmp	dil,	dl
	je	div
	jmp	handlebadop
add:	add	r9,	r10
	jmp	end
sub:	sub	r9,	r10
	jmp	end
mul:	mov	rax,	r9
	mul	r10
	mov	r9,	rax
	jmp	end
div:	mov	rax,	r9
	xor	rdx,	rdx
	div	r10
	mov	r9,	rax
	jmp	end
end:	tohexdu	rdx,	rsi,	r9
	mov	[buff],	rdx
	mov	[buff+8],	byte	0x0A
	mov	rax,	sys_write
	mov	rdi,	stdout
	mov	rsi,	buff
	mov	rdx,	8
	syscall
	mov	rax,	sys_ret
	mov	rdi,	0
	syscall
